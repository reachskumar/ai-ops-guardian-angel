
import { supabase } from "@/integrations/supabase/client";

export interface VulnerabilityData {
  id: string;
  vulnerability_id: string;
  title: string;
  description: string;
  severity: string;
  cvss_score: number;
  affected_component: string;
  status: string;
  discovered_at: string;
  remediation_steps: string;
  external_references?: string[];
  tags?: string[];
}

export interface ScanConfiguration {
  name: string;
  description?: string;
  scan_type: string;
  target_type: string;
  target_identifier: string;
  scan_engine: string;
  scan_parameters?: Record<string, any>;
}

export interface ScanResult {
  id: string;
  configuration_id: string;
  status: 'pending' | 'in_progress' | 'completed' | 'failed';
  started_at: string;
  completed_at?: string;
  summary?: {
    total: number;
    by_severity: {
      critical: number;
      high: number;
      medium: number;
      low: number;
    };
  };
  error_message?: string;
}

// Get all vulnerabilities with filtering options
export const getVulnerabilities = async (options?: {
  severity?: string;
  status?: string;
  component?: string;
  limit?: number;
}): Promise<{ vulnerabilities: VulnerabilityData[]; error?: string }> => {
  try {
    let query = supabase
      .from('vulnerabilities')
      .select('*')
      .order('discovered_at', { ascending: false });

    if (options?.severity) {
      query = query.eq('severity', options.severity);
    }

    if (options?.status) {
      query = query.eq('status', options.status);
    }

    if (options?.component) {
      query = query.ilike('affected_component', `%${options.component}%`);
    }

    if (options?.limit) {
      query = query.limit(options.limit);
    }

    const { data, error } = await query;

    if (error) throw error;

    // Transform the data to match our interface
    const vulnerabilities: VulnerabilityData[] = (data || []).map(item => ({
      id: item.id,
      vulnerability_id: item.vulnerability_id,
      title: item.title,
      description: item.description || '',
      severity: item.severity,
      cvss_score: item.cvss_score || 0,
      affected_component: item.affected_component || '',
      status: item.status,
      discovered_at: item.discovered_at,
      remediation_steps: item.remediation_steps || '',
      external_references: Array.isArray(item.external_references) 
        ? item.external_references as string[]
        : item.external_references 
          ? JSON.parse(item.external_references as string)
          : [],
      tags: Array.isArray(item.tags) ? item.tags : []
    }));

    return { vulnerabilities };
  } catch (error: any) {
    console.error("Error fetching vulnerabilities:", error);
    return { 
      vulnerabilities: [], 
      error: `Failed to fetch vulnerabilities: ${error.message}` 
    };
  }
};

// Create a new scan configuration
export const createScanConfiguration = async (
  config: ScanConfiguration
): Promise<{ configId?: string; error?: string }> => {
  try {
    const { data, error } = await supabase
      .from('security_scan_configurations')
      .insert({
        name: config.name,
        description: config.description,
        scan_type: config.scan_type,
        target_type: config.target_type,
        target_identifier: config.target_identifier,
        scan_engine: config.scan_engine,
        scan_parameters: config.scan_parameters || {}
      })
      .select()
      .single();

    if (error) throw error;

    return { configId: data.id };
  } catch (error: any) {
    console.error("Error creating scan configuration:", error);
    return { error: `Failed to create scan configuration: ${error.message}` };
  }
};

// Start a vulnerability scan
export const startVulnerabilityScan = async (
  scanConfig: ScanConfiguration
): Promise<{ scanId?: string; error?: string }> => {
  try {
    const { data, error } = await supabase.functions.invoke('security-scan', {
      body: {
        scanType: scanConfig.scan_type,
        targetType: scanConfig.target_type,
        targetIdentifier: scanConfig.target_identifier,
        scanEngine: scanConfig.scan_engine,
        parameters: scanConfig.scan_parameters
      }
    });

    if (error) throw error;

    return { scanId: data.scan_id };
  } catch (error: any) {
    console.error("Error starting vulnerability scan:", error);
    return { error: `Failed to start scan: ${error.message}` };
  }
};

// Get scan results
export const getScanResults = async (
  scanId?: string
): Promise<{ scans: ScanResult[]; error?: string }> => {
  try {
    let query = supabase
      .from('security_scans')
      .select('*')
      .order('started_at', { ascending: false });

    if (scanId) {
      query = query.eq('id', scanId);
    }

    const { data, error } = await query;

    if (error) throw error;

    // Transform the data to match our interface
    const scans: ScanResult[] = (data || []).map(item => {
      // Parse summary if it's a string
      let summary;
      if (item.summary) {
        if (typeof item.summary === 'string') {
          try {
            summary = JSON.parse(item.summary);
          } catch {
            summary = undefined;
          }
        } else {
          summary = item.summary as any;
        }
      }

      return {
        id: item.id,
        configuration_id: item.configuration_id || '',
        status: item.status as 'pending' | 'in_progress' | 'completed' | 'failed',
        started_at: item.started_at || '',
        completed_at: item.completed_at || undefined,
        summary: summary ? {
          total: summary.total || 0,
          by_severity: {
            critical: summary.by_severity?.critical || 0,
            high: summary.by_severity?.high || 0,
            medium: summary.by_severity?.medium || 0,
            low: summary.by_severity?.low || 0
          }
        } : undefined,
        error_message: item.error_message || undefined
      };
    });

    return { scans };
  } catch (error: any) {
    console.error("Error fetching scan results:", error);
    return { 
      scans: [], 
      error: `Failed to fetch scan results: ${error.message}` 
    };
  }
};

// Update vulnerability status
export const updateVulnerabilityStatus = async (
  vulnerabilityId: string,
  status: string,
  notes?: string
): Promise<{ success: boolean; error?: string }> => {
  try {
    const updateData: any = { status };
    
    if (status === 'resolved') {
      updateData.resolved_at = new Date().toISOString();
    }

    const { error } = await supabase
      .from('vulnerabilities')
      .update(updateData)
      .eq('id', vulnerabilityId);

    if (error) throw error;

    return { success: true };
  } catch (error: any) {
    console.error("Error updating vulnerability status:", error);
    return { 
      success: false, 
      error: `Failed to update vulnerability: ${error.message}` 
    };
  }
};

// Get vulnerability statistics
export const getVulnerabilityStats = async (): Promise<{
  stats: {
    total: number;
    by_severity: { [key: string]: number };
    by_status: { [key: string]: number };
    recent_scans: number;
  };
  error?: string;
}> => {
  try {
    // Get vulnerability counts by severity
    const { data, error } = await supabase
      .from('vulnerabilities')
      .select('severity, status, discovered_at');

    if (error) throw error;

    const vulnerabilities = data || [];
    
    const stats = {
      total: vulnerabilities.length,
      by_severity: vulnerabilities.reduce((acc, v) => {
        acc[v.severity] = (acc[v.severity] || 0) + 1;
        return acc;
      }, {} as { [key: string]: number }),
      by_status: vulnerabilities.reduce((acc, v) => {
        acc[v.status] = (acc[v.status] || 0) + 1;
        return acc;
      }, {} as { [key: string]: number }),
      recent_scans: vulnerabilities.filter(v => {
        const discovered = new Date(v.discovered_at);
        const weekAgo = new Date();
        weekAgo.setDate(weekAgo.getDate() - 7);
        return discovered > weekAgo;
      }).length
    };

    return { stats };
  } catch (error: any) {
    console.error("Error fetching vulnerability stats:", error);
    return { 
      stats: { total: 0, by_severity: {}, by_status: {}, recent_scans: 0 },
      error: `Failed to fetch vulnerability statistics: ${error.message}` 
    };
  }
};
