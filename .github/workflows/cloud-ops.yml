name: ChatOps - Cloud Operations

on:
  workflow_dispatch:
    inputs:
      provider:
        description: "Cloud provider (aws|azure|gcp)"
        required: true
        type: choice
        options: [aws, azure, gcp]
      action:
        description: "Action (inventory|instance_start|instance_stop|instance_reboot|instance_resize|sg_authorize|sg_revoke|ebs_snapshot|dns_upsert|cdn_invalidate|asg_scale|rds_snapshot|rds_failover|alb_register|alb_deregister|lambda_publish|lambda_traffic|vpc_peering_create|vpc_peering_accept|privatelink_create|egress_audit)"
        required: true
      region:
        description: "Region (e.g., us-east-1)"
        required: true
      params:
        description: "JSON-encoded parameters for the action"
        required: false
        default: "{}"
      dry_run:
        description: "Plan only (no changes)"
        required: false
        default: "false"
      require_approval:
        description: "Require approval for risky changes"
        required: false
        default: "true"
      confirm:
        description: "Type 'yes' to approve execution when required"
        required: false
        default: ""
      cost_threshold:
        description: "Max projected daily cost delta (USD) before block"
        required: false
        default: "0"
      override:
        description: "Override cost gate (yes to proceed)"
        required: false
        default: ""

jobs:
  run:
    runs-on: ubuntu-latest
    environment: cloud-ops
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        if: ${{ github.event.inputs.provider == 'aws' }}
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ github.event.inputs.region }}

      - name: Parse params
        id: p
        run: |
          echo "params=${{ github.event.inputs.params }}" > params.json
          cat params.json

      - name: Assess risk and generate plan
        id: assess
        run: |
          set -euo pipefail
          ACTION=${{ github.event.inputs.action }}
          PARAMS=$(cat params.json)
          get_param() { echo "$PARAMS" | jq -r .$1; }
          RISK="low"
          PLAN="{}"
          if [ "$ACTION" = "sg_authorize" ]; then
            CIDR=$(get_param cidr)
            TP=$(get_param to_port)
            if [ "$CIDR" = "0.0.0.0/0" ] && [ ${TP:-0} -lt 1024 ]; then RISK="high"; fi
            PLAN=$(jq -n --arg action "$ACTION" --arg cidr "$CIDR" --argjson tp ${TP:-0} '{action:$action, change:"open_ingress", cidr:$cidr, to_port:$tp}')
          elif [ "$ACTION" = "instance_stop" ] || [ "$ACTION" = "instance_start" ]; then
            COUNT=$(get_param instance_ids | jq 'length')
            if [ ${COUNT:-0} -gt 3 ]; then RISK="medium"; fi
            PLAN=$(jq -n --arg action "$ACTION" --argjson count ${COUNT:-0} '{action:$action, instances:$count}')
          else
            PLAN=$(jq -n --arg action "$ACTION" '{action:$action, details:"standard"}')
          fi
          # Add rollback hint
          RB="{}"
          if [ "$ACTION" = "sg_authorize" ]; then RB=$(echo $PLAN | jq '{rollback:{action:"sg_revoke",sg_id:null,protocol:null,from_port:null,to_port:.to_port,cidr:.cidr}}'); fi
          if [ "$ACTION" = "instance_stop" ]; then RB=$(echo $PLAN | jq '{rollback:{action:"instance_start"}}'); fi
          if [ "$ACTION" = "instance_start" ]; then RB=$(echo $PLAN | jq '{rollback:{action:"instance_stop"}}'); fi
          echo $(jq -s '.[0] * .[1]' <(echo $PLAN) <(echo $RB)) > plan.json
          # OPA policy check (cloud plan)
          curl -L https://github.com/open-policy-agent/conftest/releases/download/v0.52.0/conftest_0.52.0_Linux_x86_64.tar.gz | tar xz
          sudo mv conftest /usr/local/bin/
          conftest test -p policies/opa/cloud plan.json || true
          echo "risk=$RISK" >> $GITHUB_OUTPUT
          echo "$RISK" > risk.txt

      - name: Cost diff gate
        id: costgate
        run: |
          set -euo pipefail
          THRESH=${{ github.event.inputs.cost_threshold }}
          if [ -z "$THRESH" ] || [ "$THRESH" = "0" ]; then echo '{"skipped":true}' > cost_diff.json; exit 0; fi
          PROVIDER=${{ github.event.inputs.provider }}
          ACTION=${{ github.event.inputs.action }}
          PARAMS=$(cat params.json)
          get_param() { echo "$PARAMS" | jq -r .$1; }
          PROJ_DELTA=0
          if [ "$PROVIDER" = "aws" ]; then
            # Fetch yesterday's total cost as baseline
            END=$(date -u +%Y-%m-%d)
            START=$(date -u -d "yesterday" +%Y-%m-%d 2>/dev/null || date -u -v-1d +%Y-%m-%d)
            BASE=0
            if aws ce get-cost-and-usage --time-period Start=$START,End=$END --granularity=DAILY --metrics UnblendedCost >/tmp/ce.json 2>/dev/null; then
              BASE=$(jq -r '.ResultsByTime[0].Total.UnblendedCost.Amount // "0"' /tmp/ce.json)
            fi
            # Naive projection for ASG scale: assume $0.10/hr per instance for 24h
            if [ "$ACTION" = "asg_scale" ]; then
              DES=$(get_param desired); INC=$DES
              PROJ_DELTA=$(python - <<PY
d=$INC
print(f"{d*0.10*24:.2f}")
PY
)
            fi
            echo "{"baseline":$BASE,"projected_delta":$PROJ_DELTA}" | jq . > cost_diff.json
          else
            # Placeholder for Azure/GCP; skip
            echo '{"skipped":true}' > cost_diff.json
          fi
          if [ "$THRESH" != "0" ] && jq -e ".projected_delta > ($THRESH|tonumber)" cost_diff.json >/dev/null 2>&1; then
            echo "Projected cost delta exceeds threshold $THRESH. Re-run with override=yes to proceed." | tee cost_gate.txt
            if [ "${{ github.event.inputs.override }}" != "yes" ]; then exit 3; fi
          fi

      - name: Approval gate (2-person via environment)
        if: ${{ github.event.inputs.require_approval == 'true' && github.event.inputs.dry_run != 'true' && github.event.inputs.confirm != 'yes' }}
        run: |
          echo "Approval required. Risk: ${{ steps.assess.outputs.risk }}. Re-run with confirm: 'yes' to proceed." | tee gate.txt
          exit 2

      - name: Execute AWS action
        if: ${{ github.event.inputs.provider == 'aws' && github.event.inputs.dry_run != 'true' }}
        env:
          ACTION: ${{ github.event.inputs.action }}
          REGION: ${{ github.event.inputs.region }}
        run: |
          set -euo pipefail
          PARAMS=$(cat params.json)
          get_param() { echo "$PARAMS" | jq -r .$1; }
          case "$ACTION" in
            inventory)
              aws ec2 describe-instances --query 'Reservations[].Instances[].{Id:InstanceId,Type:InstanceType,State:State.Name,AZ:Placement.AvailabilityZone,Name:Tags[?Key==`Name`].Value|[0]}' --output table | tee inventory.txt
              ;;
            instance_start)
              IDS=$(get_param instance_ids | jq -r 'join(" ")')
              aws ec2 start-instances --instance-ids $IDS | tee op.txt
              ;;
            instance_stop)
              IDS=$(get_param instance_ids | jq -r 'join(" ")')
              aws ec2 stop-instances --instance-ids $IDS | tee op.txt
              ;;
            instance_reboot)
              IDS=$(get_param instance_ids | jq -r 'join(" ")')
              aws ec2 reboot-instances --instance-ids $IDS | tee op.txt
              ;;
            instance_resize)
              ID=$(get_param instance_id)
              TYPE=$(get_param instance_type)
              aws ec2 modify-instance-attribute --instance-id "$ID" --instance-type "\"$TYPE\"" | tee op.txt
              ;;
            sg_authorize)
              SG=$(get_param sg_id); PROTO=$(get_param protocol); FP=$(get_param from_port); TP=$(get_param to_port); CIDR=$(get_param cidr)
              aws ec2 authorize-security-group-ingress --group-id "$SG" --ip-permissions IpProtocol=$PROTO,FromPort=$FP,ToPort=$TP,IpRanges="[{CidrIp=$CIDR}]" | tee op.txt
              ;;
            sg_revoke)
              SG=$(get_param sg_id); PROTO=$(get_param protocol); FP=$(get_param from_port); TP=$(get_param to_port); CIDR=$(get_param cidr)
              aws ec2 revoke-security-group-ingress --group-id "$SG" --ip-permissions IpProtocol=$PROTO,FromPort=$FP,ToPort=$TP,IpRanges="[{CidrIp=$CIDR}]" | tee op.txt
              ;;
            ebs_snapshot)
              VOL=$(get_param volume_id); DESC=$(get_param description)
              aws ec2 create-snapshot --volume-id "$VOL" --description "$DESC" | tee op.txt
              ;;
            dns_upsert)
              ZONE=$(get_param zone_id); NAME=$(get_param name); RTYPE=$(get_param rtype); VALUE=$(get_param value); TTL=$(get_param ttl)
              cat > change-batch.json <<JSON
              {"Changes":[{"Action":"UPSERT","ResourceRecordSet":{"Name":"$NAME","Type":"$RTYPE","TTL":${TTL:-60},"ResourceRecords":[{"Value":"$VALUE"}]}}]}
JSON
              aws route53 change-resource-record-sets --hosted-zone-id "$ZONE" --change-batch file://change-batch.json | tee op.txt
              ;;
            cdn_invalidate)
              DIST=$(get_param distribution_id); PATHS=$(get_param paths | jq -c .)
              aws cloudfront create-invalidation --distribution-id "$DIST" --paths $(echo $PATHS | jq -r 'join(" ")') | tee op.txt
              ;;
            asg_scale)
              ASG=$(get_param asg_name); DESIRED=$(get_param desired)
              aws autoscaling set-desired-capacity --auto-scaling-group-name "$ASG" --desired-capacity "$DESIRED" --no-honor-cooldown | tee op.txt
              ;;
            rds_snapshot)
              DB=$(get_param db_instance_id); SNAP=$(get_param snapshot_id)
              aws rds create-db-snapshot --db-instance-identifier "$DB" --db-snapshot-identifier "$SNAP" | tee op.txt
              ;;
            rds_failover)
              DB=$(get_param db_instance_id)
              aws rds reboot-db-instance --db-instance-identifier "$DB" --force-failover | tee op.txt
              ;;
            alb_register)
              TG=$(get_param target_group_arn); IDS=$(get_param target_ids | jq -r 'join(" ")')
              aws elbv2 register-targets --target-group-arn "$TG" --targets $(for id in $IDS; do echo Id=$id; done) | tee op.txt ;;
            alb_deregister)
              TG=$(get_param target_group_arn); IDS=$(get_param target_ids | jq -r 'join(" ")')
              aws elbv2 deregister-targets --target-group-arn "$TG" --targets $(for id in $IDS; do echo Id=$id; done) | tee op.txt ;;
            lambda_publish)
              FN=$(get_param function_name); DESC=$(get_param description)
              aws lambda publish-version --function-name "$FN" --description "$DESC" | tee op.txt ;;
            lambda_traffic)
              FN=$(get_param function_name); ALIAS=$(get_param alias); VER=$(get_param version); WEIGHTS=$(get_param weights)
              if [ "$WEIGHTS" != "null" ]; then echo "$WEIGHTS" > weights.json; aws lambda update-alias --function-name "$FN" --name "$ALIAS" --function-version "$VER" --routing-config fileb://weights.json | tee op.txt; else aws lambda update-alias --function-name "$FN" --name "$ALIAS" --function-version "$VER" | tee op.txt; fi ;;
            vpc_peering_create)
              VPC=$(get_param vpc_id); PVPC=$(get_param peer_vpc_id); PREG=$(get_param peer_region)
              if [ "$PREG" != "null" ]; then aws ec2 create-vpc-peering-connection --vpc-id "$VPC" --peer-vpc-id "$PVPC" --peer-region "$PREG" | tee op.txt; else aws ec2 create-vpc-peering-connection --vpc-id "$VPC" --peer-vpc-id "$PVPC" | tee op.txt; fi ;;
            vpc_peering_accept)
              PCX=$(get_param peering_connection_id)
              aws ec2 accept-vpc-peering-connection --vpc-peering-connection-id "$PCX" | tee op.txt ;;
            privatelink_create)
              VPC=$(get_param vpc_id); SVC=$(get_param service_name); SUBS=$(get_param subnet_ids | jq -r 'join(" ")'); SGS=$(get_param sg_ids | jq -r 'join(" ")')
              aws ec2 create-vpc-endpoint --vpc-id "$VPC" --service-name "$SVC" --vpc-endpoint-type Interface --subnet-ids $SUBS --security-group-ids $SGS | tee op.txt ;;
            egress_audit)
              aws ec2 describe-security-groups | jq '[.SecurityGroups[] | {GroupId, Egress: .IpPermissionsEgress}]' > op.txt ;;
            *)
              echo "Unsupported action: $ACTION"; exit 1;
              ;;
          esac

      - name: Azure login
        if: ${{ github.event.inputs.provider == 'azure' }}
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Execute Azure action
        if: ${{ github.event.inputs.provider == 'azure' && github.event.inputs.dry_run != 'true' }}
        run: |
          set -euo pipefail
          PARAMS=$(cat params.json)
          get_param() { echo "$PARAMS" | jq -r .$1; }
          ACTION=${{ github.event.inputs.action }}
          case "$ACTION" in
            inventory)
              az vm list -o table | tee inventory.txt ;;
            instance_start)
              RG=$(get_param resource_group); NAME=$(get_param vm_name)
              az vm start -g "$RG" -n "$NAME" | tee op.txt ;;
            instance_stop)
              RG=$(get_param resource_group); NAME=$(get_param vm_name)
              az vm deallocate -g "$RG" -n "$NAME" | tee op.txt ;;
            vmss_scale)
              RG=$(get_param resource_group); NAME=$(get_param vmss_name); CAP=$(get_param capacity)
              az vmss scale -g "$RG" -n "$NAME" --new-capacity "$CAP" | tee op.txt ;;
            dns_upsert)
              RG=$(get_param resource_group); ZONE=$(get_param zone_name); RR=$(get_param record_name); RTYPE=$(get_param rtype); TTL=$(get_param ttl); VAL=$(get_param value)
              az network dns record-set $RTYPE create -g "$RG" -z "$ZONE" -n "$RR" --ttl ${TTL:-60}
              az network dns record-set $RTYPE add-record -g "$RG" -z "$ZONE" -n "$RR" --record "$VAL" | tee op.txt ;;
            cdn_purge)
              PROF=$(get_param profile); ENDPT=$(get_param endpoint); CONTENT=$(get_param content_paths | jq -r 'join(",")')
              az cdn endpoint purge -g $(get_param resource_group) -n "$ENDPT" --profile-name "$PROF" --content-paths $CONTENT | tee op.txt ;;
            waf_rule)
              # Example: enable rule group; expects policy and rule json in params
              POLICY=$(get_param policy_name); RG=$(get_param resource_group)
              az network front-door waf-policy update -g "$RG" -n "$POLICY" --mode Prevention | tee op.txt || true ;;
            storage_lifecycle)
              ACC=$(get_param account); RG=$(get_param resource_group); POLICY=$(get_param policy_json)
              echo "$POLICY" > policy.json
              az storage account management-policy create -g "$RG" -n "$ACC" --policy @policy.json | tee op.txt ;;
            sql_failover)
              FG=$(get_param failover_group); RG=$(get_param resource_group); SERVER=$(get_param server)
              az sql failover-group set-primary -g "$RG" -s "$SERVER" -n "$FG" | tee op.txt ;;
            *) echo "Unsupported azure action: $ACTION"; exit 1;;
          esac

      - name: Setup gcloud
        if: ${{ github.event.inputs.provider == 'gcp' }}
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SERVICE_ACCOUNT_KEY }}

      - name: Execute GCP action
        if: ${{ github.event.inputs.provider == 'gcp' && github.event.inputs.dry_run != 'true' }}
        run: |
          set -euo pipefail
          PARAMS=$(cat params.json)
          get_param() { echo "$PARAMS" | jq -r .$1; }
          ACTION=${{ github.event.inputs.action }}
          PROJECT=${{ github.event.inputs.region }} # reuse field for project if needed
          case "$ACTION" in
            inventory)
              gcloud compute instances list --project "$PROJECT" | tee inventory.txt ;;
            instance_start)
              ZONE=$(get_param zone); NAME=$(get_param instance)
              gcloud compute instances start "$NAME" --zone "$ZONE" --project "$PROJECT" | tee op.txt ;;
            instance_stop)
              ZONE=$(get_param zone); NAME=$(get_param instance)
              gcloud compute instances stop "$NAME" --zone "$ZONE" --project "$PROJECT" | tee op.txt ;;
            mig_scale)
              ZONE=$(get_param zone); GROUP=$(get_param mig_name); SIZE=$(get_param size)
              gcloud compute instance-groups managed resize "$GROUP" --size "$SIZE" --zone "$ZONE" --project "$PROJECT" | tee op.txt ;;
            dns_upsert)
              ZONE=$(get_param zone_name); RR=$(get_param record_name); RTYPE=$(get_param rtype); VAL=$(get_param value); TTL=$(get_param ttl)
              gcloud dns record-sets transaction start --zone="$ZONE" --project "$PROJECT"
              gcloud dns record-sets transaction add "$VAL" --name="$RR" --ttl=${TTL:-60} --type="$RTYPE" --zone="$ZONE" --project "$PROJECT"
              gcloud dns record-sets transaction execute --zone="$ZONE" --project "$PROJECT" | tee op.txt ;;
            cdn_invalidate)
              URLMAP=$(get_param url_map); PATHS=$(get_param content_paths | jq -r 'join(",")')
              gcloud compute url-maps invalidate-cdn-cache "$URLMAP" --path "$PATHS" --project "$PROJECT" | tee op.txt ;;
            armor_rule)
              POLICY=$(get_param policy_name); PRIORITY=$(get_param priority); ACTION=$(get_param rule_action)
              gcloud compute security-policies rules update "$PRIORITY" --security-policy "$POLICY" --action "$ACTION" --project "$PROJECT" | tee op.txt ;;
            gcs_lifecycle)
              BUCKET=$(get_param bucket); POLICY=$(get_param policy_json)
              echo "$POLICY" > lifecycle.json
              gsutil lifecycle set lifecycle.json gs://$BUCKET | tee op.txt ;;
            cloudsql_failover)
              INST=$(get_param instance)
              gcloud sql instances failover "$INST" --project "$PROJECT" | tee op.txt ;;
            *) echo "Unsupported gcp action: $ACTION"; exit 1;;
          esac

      - name: Upload output
        uses: actions/upload-artifact@v4
        with:
          name: cloud-ops-output
          path: |
            *.txt
            inventory.txt
            op.txt
            risk.txt
            plan.json
            change-batch.json
            cost_diff.json


