name: ChatOps - Kubernetes Operations

on:
  workflow_dispatch:
    inputs:
      action:
        description: "Operation to perform (deploy|scale|restart|rollout|logs)"
        required: true
        type: choice
        options: [deploy, scale, restart, rollout, logs, node, hpa_update, quota_update, config_apply, secret_apply, events, node_replace, promote, abort]
      environment:
        description: "Target environment (staging|production)"
        required: true
        type: choice
        options: [staging, production]
      service:
        description: "Service name (api-gateway|ai-services|frontend)"
        required: true
        type: choice
        options: [api-gateway, ai-services, frontend]
      strategy:
        description: "Deployment strategy (rolling|blue_green|canary)"
        required: false
        default: rolling
      replicas:
        description: "Number of replicas (for scale)"
        required: false
      subaction:
        description: "Rollout subaction (status|pause|resume|undo)"
        required: false
      tail:
        description: "Tail lines for logs"
        required: false
        default: "200"
      node_name:
        description: "Node name for maintenance actions"
        required: false
      min_replicas:
        description: "HPA min replicas"
        required: false
      max_replicas:
        description: "HPA max replicas"
        required: false
      target_cpu:
        description: "HPA target CPU utilization percentage"
        required: false
      quota_yaml:
        description: "ResourceQuota YAML (base64-encoded)"
        required: false
      manifest_yaml:
        description: "Config/Secret YAML (base64-encoded)"
        required: false

jobs:
  run:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: latest

      - name: Install Argo Rollouts CLI
        run: |
          curl -sLo kubectl-argo-rollouts https://github.com/argoproj/argo-rollouts/releases/latest/download/kubectl-argo-rollouts-linux-amd64
          sudo install -m 0755 kubectl-argo-rollouts /usr/local/bin/kubectl-argo-rollouts

      - name: Configure kubeconfig
        run: |
          if [ "${{ github.event.inputs.environment }}" = "production" ]; then
            echo "${{ secrets.KUBE_CONFIG_PRODUCTION }}" | base64 -d > kubeconfig
          else
            echo "${{ secrets.KUBE_CONFIG_STAGING }}" | base64 -d > kubeconfig
          fi
          echo "KUBECONFIG=$PWD/kubeconfig" >> $GITHUB_ENV

      - name: Select namespace
        id: ns
        run: |
          if [ "${{ github.event.inputs.environment }}" = "production" ]; then
            echo "ns=ai-ops-production" >> $GITHUB_OUTPUT
          else
            echo "ns=ai-ops-staging" >> $GITHUB_OUTPUT
          fi

      - name: Execute operation
        env:
          NAMESPACE: ${{ steps.ns.outputs.ns }}
          SERVICE: ${{ github.event.inputs.service }}
          ACTION: ${{ github.event.inputs.action }}
          STRATEGY: ${{ github.event.inputs.strategy }}
          REPLICAS: ${{ github.event.inputs.replicas }}
          SUBACTION: ${{ github.event.inputs.subaction }}
          TAIL: ${{ github.event.inputs.tail }}
          NODE_NAME: ${{ github.event.inputs.node_name }}
          MIN_REPLICAS: ${{ github.event.inputs.min_replicas }}
          MAX_REPLICAS: ${{ github.event.inputs.max_replicas }}
          TARGET_CPU: ${{ github.event.inputs.target_cpu }}
          QUOTA_YAML: ${{ github.event.inputs.quota_yaml }}
          MANIFEST_YAML: ${{ github.event.inputs.manifest_yaml }}
        run: |
          set -euo pipefail
          echo "Action: $ACTION, Service: $SERVICE, Namespace: $NAMESPACE"
          DEPLOYMENT="$SERVICE"
          case "$ACTION" in
            deploy)
              # Rolling deploy by default: restart to pick up new image tag in manifests
              kubectl -n "$NAMESPACE" rollout restart deployment "$DEPLOYMENT"
              kubectl -n "$NAMESPACE" rollout status deployment "$DEPLOYMENT" --timeout=5m
              ;;
            promote)
              # Promote Argo Rollout to 100%
              kubectl -n "$NAMESPACE" argo rollouts promote "$DEPLOYMENT" || true
              ;;
            abort)
              # Abort current canary and rollback
              kubectl -n "$NAMESPACE" argo rollouts abort "$DEPLOYMENT" || true
              ;;
            scale)
              if [ -z "${REPLICAS:-}" ]; then echo "replicas is required"; exit 1; fi
              kubectl -n "$NAMESPACE" scale deployment "$DEPLOYMENT" --replicas="$REPLICAS"
              kubectl -n "$NAMESPACE" rollout status deployment "$DEPLOYMENT" --timeout=5m
              ;;
            restart)
              kubectl -n "$NAMESPACE" rollout restart deployment "$DEPLOYMENT"
              kubectl -n "$NAMESPACE" rollout status deployment "$DEPLOYMENT" --timeout=5m
              ;;
            rollout)
              case "${SUBACTION:-status}" in
                status)
                  kubectl -n "$NAMESPACE" rollout status deployment "$DEPLOYMENT" --timeout=2m
                  ;;
                pause)
                  kubectl -n "$NAMESPACE" rollout pause deployment "$DEPLOYMENT"
                  ;;
                resume)
                  kubectl -n "$NAMESPACE" rollout resume deployment "$DEPLOYMENT"
                  ;;
                undo)
                  kubectl -n "$NAMESPACE" rollout undo deployment "$DEPLOYMENT"
                  ;;
              esac
              ;;
            logs)
              mkdir -p logs
              for p in $(kubectl -n "$NAMESPACE" get pods -l app="$DEPLOYMENT" -o name); do
                kubectl -n "$NAMESPACE" logs "$p" --all-containers --tail="${TAIL:-200}" > "logs/${p##*/}.log" || true
              done
              ;;
            events)
              kubectl -n "$NAMESPACE" get events --sort-by=.metadata.creationTimestamp > logs/events.log || true
              ;;
            node)
              if [ -z "${NODE_NAME:-}" ]; then echo "node_name is required"; exit 1; fi
              case "${SUBACTION:-status}" in
                cordon) kubectl cordon "$NODE_NAME" ;;
                drain) kubectl drain "$NODE_NAME" --ignore-daemonsets --delete-emptydir-data --force ;;
                uncordon) kubectl uncordon "$NODE_NAME" ;;
                *) kubectl get node "$NODE_NAME" -o wide ;;
              esac
              ;;
            node_replace)
              if [ -z "${NODE_NAME:-}" ]; then echo "node_name is required"; exit 1; fi
              kubectl cordon "$NODE_NAME" || true
              kubectl drain "$NODE_NAME" --ignore-daemonsets --delete-emptydir-data --force || true
              echo "Please replace node at the infrastructure layer, then run node uncordon." 
              ;;
            hpa_update)
              if [ -z "${MIN_REPLICAS:-}" ] || [ -z "${MAX_REPLICAS:-}" ] || [ -z "${TARGET_CPU:-}" ]; then echo "min_replicas, max_replicas and target_cpu are required"; exit 1; fi
              kubectl -n "$NAMESPACE" autoscale deployment "$DEPLOYMENT" --min=${MIN_REPLICAS} --max=${MAX_REPLICAS} --cpu-percent=${TARGET_CPU}
              kubectl -n "$NAMESPACE" get hpa "$DEPLOYMENT" -o yaml
              ;;
            quota_update)
              if [ -z "${QUOTA_YAML:-}" ]; then echo "quota_yaml is required"; exit 1; fi
              echo "$QUOTA_YAML" | base64 -d > quota.yaml
              kubectl -n "$NAMESPACE" apply -f quota.yaml
              kubectl -n "$NAMESPACE" get resourcequota -o wide
              ;;
            config_apply|secret_apply)
              if [ -z "${MANIFEST_YAML:-}" ]; then echo "manifest_yaml is required"; exit 1; fi
              echo "$MANIFEST_YAML" | base64 -d > manifest.yaml
              kubectl -n "$NAMESPACE" apply -f manifest.yaml
              ;;
            *)
              echo "Unknown action: $ACTION"; exit 1;
              ;;
          esac

      - name: Upload logs artifact (if any)
        if: success() && github.event.inputs.action == 'logs'
        uses: actions/upload-artifact@v4
        with:
          name: k8s-logs-${{ github.event.inputs.service }}-${{ github.event.inputs.environment }}
          path: logs


